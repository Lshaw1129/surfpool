name: Run Surfpool Tests (July 2025 + MCAP/LIQ/VOLUME filters + Real PnL)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  # ---- Your trading/filters ----
  SLIPPAGE_BPS: "500"                  # 5% slippage
  INCLUDE_PRIORITY_FEE: "true"

  MIN_MARKET_CAP: "50000"              # USD
  MAX_MARKET_CAP: "60000"              # USD

  MIN_LIQUIDITY: "10000"               # USD
  MAX_LIQUIDITY: "2000000"             # USD

  MIN_VOLUME: "10000"                  # USD (24h)
  MAX_VOLUME: "200000"                 # USD (24h)

  MAX_AGE_MINUTES: "60"                # (not enforced here)
  PRIORITY_TOKEN_AGE_MINUTES: "15"     # (not enforced here)

  TAKE_PROFIT_PCT: "3.0"               # 300% TP
  STOP_LOSS_PCT:  "0.2"                # 20%  SL
  TRADE_SIZE_USD: "100"                # $100 notional per trade

  # ---- Rotating RPCs for signature fetch ----
  RPC_ROTATE_1: "https://mainnet.helius-rpc.com/?api-key=02a76c9f-34e8-4acf-bf36-c2b10b2a7fe2"
  RPC_ROTATE_2: "https://api.mainnet-beta.solana.com"

  # ---- Constants ----
  USDC_MINT: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"       # USDC
  JUP_ROUTER: "JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB"       # Jupiter program (router)

jobs:
  test-surfpool:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Rust toolchain + cache
        uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2

      - name: Build Surfpool (release)
        run: cargo build --release --locked

      - name: Prepare workspace
        run: mkdir -p data out

      - name: Generate July 2025 Jupiter signatures (rotating RPCs + backoff)
        shell: bash
        run: |
          set -euo pipefail
          cat > fetch_july_jupiter.js <<'JS'
          const https=require("https"),fs=require("fs");
          const ADDR=process.env.JUP_ROUTER;
          const START=Math.floor(new Date("2025-07-01T00:00:00Z").getTime()/1000);
          const END  =Math.floor(new Date("2025-07-31T23:59:59Z").getTime()/1000);
          const RPCS=[process.env.RPC_ROTATE_1, process.env.RPC_ROTATE_2].filter(Boolean);
          let rpcIdx=0;
          function rpc(method,params){
            return new Promise((res,rej)=>{
              const url=RPCS[rpcIdx%RPCS.length]; rpcIdx++;
              const body=JSON.stringify({jsonrpc:"2.0",id:1,method,params});
              const u=new URL(url);
              const req=https.request({hostname:u.hostname, path:u.pathname+u.search, protocol:u.protocol, method:"POST",
                headers:{"Content-Type":"application/json"}}, r=>{ let b=""; r.on("data",c=>b+=c); r.on("end",()=>{ try{res(JSON.parse(b))}catch(e){rej(e)} }) });
              req.on("error",rej); req.write(body); req.end();
            });
          }
          const sleep = ms => new Promise(r=>setTimeout(r,ms));
          async function backoff(fn,max=6){ let d=500; for(let i=0;i<max;i++){ try{return await fn()}catch(e){ if(i===max-1) throw e; await sleep(d); d*=2; }}}

          (async()=>{
            let out=[], before=null;
            for(;;){
              const params = before ? [ADDR,{limit:1000,before}] : [ADDR,{limit:1000}];
              const resp=await backoff(()=>rpc("getSignaturesForAddress", params));
              const arr=resp.result||[];
              if(!arr.length) break;

              let keepPaging=true;
              for(const x of arr){
                const t=x.blockTime|0; if(!t) continue;
                if(t<START){ keepPaging=false; break; }
                if(t<=END) out.push({signature:x.signature,blockTime:t});
              }
              if(!keepPaging) break;
              before=arr[arr.length-1]?.signature;
              if(!before) break;
              await sleep(150);
            }
            out.sort((a,b)=>(a.blockTime||0)-(b.blockTime||0));
            fs.writeFileSync("data/surfpool-replay.json",JSON.stringify(out,null,2));
            console.log("Signatures in July:", out.length);
          })().catch(e=>{ console.error(e); process.exit(1); });
          JS
          node fetch_july_jupiter.js
          test -s data/surfpool-replay.json

      - name: Start Surfpool localnet (background)
        run: |
          nohup ./target/release/surfpool run localnet --rpc-url "${{ env.RPC_ROTATE_2 }}" --verbose > out/localnet.log 2>&1 &
          echo $! > out/localnet.pid
          sleep 5

      - name: Replay July file
        run: |
          ./target/release/surfpool replay --file data/surfpool-replay.json --speed 10 --verbose > out/replay.log 2>&1 || true

      - name: Strategy (REAL PnL + win rate; Jupiter Token API V2 for MCAP/LIQ/VOLUME)
        shell: bash
        env:
          HELIUS_KEY: ${{ secrets.HELIUS_KEY }}
          USDC_MINT: ${{ env.USDC_MINT }}
        run: |
          set -euo pipefail
          node - <<'JS'
          const fs=require('fs'); const https=require('https');

          const USDC=process.env.USDC_MINT;
          const HKEY=process.env.HELIUS_KEY;

          const F={
            SLIPPAGE_BPS:+process.env.SLIPPAGE_BPS,
            TAKE_PROFIT_PCT:+process.env.TAKE_PROFIT_PCT,
            STOP_LOSS_PCT:+process.env.STOP_LOSS_PCT,
            TRADE_SIZE_USD:+process.env.TRADE_SIZE_USD,
            MIN_VOLUME:+process.env.MIN_VOLUME,
            MAX_VOLUME:+process.env.MAX_VOLUME,
            MIN_MCAP:+process.env.MIN_MARKET_CAP,
            MAX_MCAP:+process.env.MAX_MARKET_CAP,
            MIN_LIQ:+process.env.MIN_LIQUIDITY,
            MAX_LIQ:+process.env.MAX_LIQUIDITY,
          };

          const sigs=JSON.parse(fs.readFileSync('data/surfpool-replay.json','utf8'));

          const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
          async function backoff(fn, max=6){ let d=500; for(let i=0;i<max;i++){ try{ return await fn(); }catch(e){ if(i===max-1) throw e; await sleep(d); d*=2; } } }
          function httpGetJSON(url){ return new Promise((res,rej)=>{
            https.get(url, r=>{ let b=''; r.on('data',c=>b+=c); r.on('end',()=>{ try{
              if(r.statusCode && r.statusCode>=400) return rej(new Error(`HTTP ${r.statusCode}: ${b}`));
              res(JSON.parse(b));
            }catch(e){ rej(e) } }); }).on('error',rej);
          });}

          // --- Helius: pull the full txs set (throttled) ---
          async function heliusFetchBatch(signatures, batchSize=20){
            let out=[], i=0;
            while(i<signatures.length){
              const chunk=signatures.slice(i,i+batchSize).map(s=>`txs[]=${encodeURIComponent(s.signature)}`).join('&');
              const url=`https://api.helius.xyz/v0/transactions/?api-key=${HKEY}&${chunk}`;
              const data=await backoff(()=>httpGetJSON(url));
              out.push(...data);
              i+=batchSize;
              await sleep(350); // pace
            }
            return out;
          }

          // Gather all non-USDC mints that traded vs USDC
          function extractTokenMints(txs){
            const set=new Set();
            for(const tx of txs){
              const tt=tx?.tokenTransfers||[];
              const usdc=tt.find(z=>z.mint===USDC);
              const other=tt.find(z=>z.mint && z.mint!==USDC);
              if(usdc && other) set.add(other.mint);
            }
            return Array.from(set);
          }

          // --- Jupiter Token API V2: batch token stats (mcap, liquidity, stats24h) ---
          async function jupTokenStats(mints){
            const out=new Map();
            for(let i=0;i<mints.length;i+=100){
              const chunk=mints.slice(i,i+100);
              const url=`https://lite-api.jup.ag/tokens/v2/search?query=${encodeURIComponent(chunk.join(','))}`;
              const json=await backoff(()=>httpGetJSON(url));
              for(const t of (json||[])){
                const mint=t?.mint || t?.id || t?.address;
                if(!mint) continue;
                const mcap = +((t?.mcap ?? t?.marketCap ?? 0) || 0);
                const liq  = +((t?.liquidity ?? t?.stats24h?.liquidity ?? 0) || 0);
                const v24  = +(((t?.stats24h?.buyVolume ?? 0) + (t?.stats24h?.sellVolume ?? 0)) || 0);
                out.set(mint, {mcap, liquidity: liq, volume24h: v24});
              }
              await sleep(2000); // ~30 rpm limit
            }
            return out;
          }

          // Build per-mint price series (USDC per token) from Helius txs
          function extractPricesPerMint(txs){
            const map=new Map(); // mint -> [{t, px}]
            for(const tx of txs){
              const T=tx?.timestamp; if(!T) continue;
              const tt=tx?.tokenTransfers||[];
              const usdc=tt.find(z=>z.mint===USDC);
              const other=tt.find(z=>z.mint && z.mint!==USDC);
              if(!usdc||!other) continue;
              const usdcAmt=Math.abs(usdc.tokenAmount||0);
              const otherAmt=Math.abs(other.tokenAmount||0);
              if(!usdcAmt||!otherAmt) continue;
              const px=usdcAmt/otherAmt; // USDC per token
              const arr=map.get(other.mint)||[];
              arr.push({t:T, px});
              map.set(other.mint, arr);
            }
            for(const [k,v] of map) v.sort((a,b)=>a.t-b.t);
            return map;
          }

          // Backtest with TP/SL + slippage
          function backtest(priceMap, allow, F){
            const trades=[];
            for(const [mint, series] of priceMap){
              if(!allow.has(mint)) continue;
              if(series.length<2) continue;
              const entryPx=series[0].px;
              const qty=F.TRADE_SIZE_USD/entryPx;

              let exit=series[series.length-1], reason='EOD';
              for(let i=1;i<series.length;i++){
                const r=(series[i].px-entryPx)/entryPx;
                if(r>=F.TAKE_PROFIT_PCT){ exit=series[i]; reason='TP'; break; }
                if(r<=-F.STOP_LOSS_PCT){ exit=series[i]; reason='SL'; break; }
              }

              const slip = F.SLIPPAGE_BPS/10000;
              const buyPx  = entryPx*(1+slip);
              const sellPx = exit.px*(1-slip);
              const pnlUSD = (sellPx - buyPx)*qty;

              trades.push({mint, entry_t:series[0].t, entry_px:entryPx, exit_t:exit.t, exit_px:exit.px, reason, qty, pnl_usd:pnlUSD});
            }
            return trades;
          }

          (async ()=>{
            if(!HKEY){ console.error("Missing HELIUS_KEY"); process.exit(1); }

            console.log(`Helius: fetching ${sigs.length} Jupiter txs...`);
            const txs = await heliusFetchBatch(sigs, 20);

            const mints = extractTokenMints(txs);
            console.log(`Unique non-USDC mints vs USDC in July: ${mints.length}`);

            console.log('Jupiter Token API V2: fetching mcap/liquidity/24h volume (batched)...');
            const stats = await jupTokenStats(mints);

            // Build allowlist by your thresholds
            const allow = new Set();
            const snapshot = [];
            for(const mint of mints){
              const s = stats.get(mint) || {mcap:0, liquidity:0, volume24h:0};
              const ok =
                s.mcap     >= F.MIN_MCAP && s.mcap     <= F.MAX_MCAP &&
                s.liquidity>= F.MIN_LIQ  && s.liquidity<= F.MAX_LIQ  &&
                s.volume24h>= F.MIN_VOLUME && s.volume24h<= F.MAX_VOLUME;
              if(ok) allow.add(mint);
              snapshot.push({mint, ...s, pass: ok});
            }
            console.log(`Allowed mints by MCAP/LIQ/VOLUME: ${allow.size}`);

            const priceMap = extractPricesPerMint(txs);
            const trades = backtest(priceMap, allow, F);

            const wins = trades.filter(t=>t.pnl_usd>0).length;
            const winRate = trades.length ? (wins/trades.length*100) : 0;
            const totalPNL = trades.reduce((a,b)=>a+b.pnl_usd,0);

            if(!fs.existsSync('out')) fs.mkdirSync('out',{recursive:true});
            fs.writeFileSync('out/token_filter_snapshot.json', JSON.stringify(snapshot, null, 2));
            fs.writeFileSync('out/trades.csv','mint,entry_t,entry_px,exit_t,exit_px,reason,qty,pnl_usd\n' +
              trades.map(t=>[t.mint,t.entry_t,t.entry_px,t.exit_t,t.exit_px,t.reason||'',t.qty,t.pnl_usd].join(',')).join('\n'));
            fs.writeFileSync('out/summary.json', JSON.stringify({
              window:{start:"2025-07-01T00:00:00Z",end:"2025-07-31T23:59:59Z"},
              filters:F,
              trade_count: trades.length,
              wins,
              win_rate_pct: +winRate.toFixed(2),
              total_revenue_usd: +totalPNL.toFixed(2)
            }, null, 2));

            console.log(`Trades=${trades.length} Wins=${wins} WinRate=${winRate.toFixed(2)}% TotalRevenueUSD=${totalPNL.toFixed(2)}`);
          })().catch(e=>{ console.error(e); process.exit(1); });
          JS

      - name: Stop Surfpool localnet
        if: always()
        run: |
          if [ -f out/localnet.pid ]; then kill "$(cat out/localnet.pid)" 2>/dev/null || true; fi

      - name: Upload artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: surfpool-test-results
          path: out/

